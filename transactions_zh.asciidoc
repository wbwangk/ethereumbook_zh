[[tx_chapter]]
== 交易

交易是由外部拥有的帐户(EOA)发起的签名消息，由以太坊网络传输，并记录（挖矿）在以太坊区块链上。在这个基本定义背后，有很多令人惊讶和迷人的细节。看待交易的另一种方式是，它们是唯一可触发状态更改或导致合约在EVM中执行的事物。以太坊是一个全球性的单一状态机器，交易是唯一可以让状态机“滴答”，改变其状态的事物。合约不会自行运行。以太坊不会在后台运行。一切都开始于交易。

在本节中，我们将剖析交易，展示他们的工作方式以及了解细节。

[[tx_struct]]
=== 交易结构

首先让我们来看看交易的基本结构，因为它是在以太坊网络上进行序列化和传输的。接收序列化交易的每个客户端和应用程序将使用自己的内部数据结构将其存储在内存中，也许会使用网络序列化交易本身不存在的元数据进行修饰。因此，交易的网络序列化是交易结构的唯一通用标准。

交易是一个序列化的二进制消息，其中包含以下数据：

nonce::  一个序列号，由发起EOA发出，用于防止消息重播。

gas price::   发起人愿意支付的燃料价格（以wei为单位）。

start gas::  发起者愿意支付的最大数量的燃料。(译者：有时叫gas limit)

to::  目的地以太坊地址。

value::  发送到目的地的以太币数量。

data::  可变长度二进制数据负载。

v,r,s::  发起EOA的三个ECDSA签名。

交易消息的结构使用递归长度前缀（RLP）编码方案（参见<<rlp>>）进行序列化，该方案专门为以太坊中精确和字节数据序列化而创建。以太坊中的所有数字都被编码为big-endian整数，其长度为8位的倍数。

请注意，为了清楚起见，上面显示了字段标签（“to”，“start gas”等），但字段标签不是交易序列化数据的组成部分（包含字段值的RLP编码）。通常，RLP不包含任何字段分隔符或标签。RLP的长度前缀用于标识每个字段的长度。因此，超出定义长度的任何内容都属于结构中的下一个字段。

虽然这是实际的交易结构传输，但大多数内部表示和用户界面可视化都使用来自交易或区块链的附加信息来修饰它。

例如，您可能会注意到识别发起人EOA的地址中没有“from”数据。EOA的公钥可以很容易地从ECDSA签名的v，r，s组件中推导出来。这个地址反过来可以很容易地从公钥中得到。当您看到显示交易的“from”字段时，那是显示交易的软件添加了该字段。经常有其他元数据被客户端软件添加到交易中，包括区块编号（一旦被挖矿）和交易ID（计算的散列）。同样，这些数据是从交易推导出来的，而不是交易信息本身的一部分。

[[tx_nonce]]
==== 交易nonce

nonce是交易中最重要和最难理解的组成部分之一。黄皮书中的定义（见<<yellow_paper>>）如下：

 nonce：一个等于此地址发送的交易数的数量值，或者对于关联代码的帐户（译者：指合约帐户），此帐户创建的合约数量。

严格地说，nonce是源地址的一个属性（它只在发送地址的上下文中有意义）。但是，该nonce并未作为账户状态的一部分显式存储在区块链中。相反，它是通过计算源自地址的已确认交易的数量来动态计算的。

nonce值也用于防止帐户余额的错误计算。例如，假设一个账户有10个以太币的余额，并且使用nonce 1和nonce 2签署了两个分别花费6个以太币的交易。这两笔交易中哪一笔有效？在像以太坊这样的分布式系统中，节点可能无序地接收交易。nonce强制任何地址的交易按顺序处理，不管间隙如何，无论节点接收到的顺序如何。这样，所有节点都会计算相同的余额。支付6以太币的交易将被成功处理，账户余额减少到4以太币。无论收到什么时候，所有节点都认为使用nonce 2的交易无效。

使用nonce确保所有节点计算出相同的余额，并正确地对交易进行排序，相当于防止比特币中的“双重支出”的机制。但是，因为以太坊追踪账户余额并且不会单独追踪硬币（在比特币中称为UTXO），所以只有在账户余额计算错误时才会发生“双重支出”。nonce机制可以防止这种情况发生。

[[tracking_nonce]]
===== 跟踪nonce

实际上，nonce是源自帐户的已 _确认_ （已挖矿）交易数的最新计数。要找到nonce是多少，您可以询问区块链，例如通过web3界面：

[[nonce_getTransactionCount]]
.检索我们示例地址的交易次数

----
web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")
40
----

[TIP]
====
nonce是一个从零起始的计数器，意味着第一个交易具有nonce 0。在<<nonce_getTransactionCount>>中，我们有一个40的交易计数，表示0到39的nonce已被查看。下一个交易的nonce将是40。 
====

您的钱包将跟踪其管理的每个地址的nonce。这很简单，只要您只是从单一点发起交易即可。假设您正在编写自己的钱包软件或其他一些发起交易的应用程序。你如何跟踪nonce？

当您创建新的交易时，您将分配序列中的下一个nonce。但在确认之前，它不会计入getTransactionCount总数。

[[get_tx_count_bug]]
不幸的是，如果我们连续发送一些交易，getTransactionCount函数会遇到一些问题。有一个已知的错误，其中getTransactionCount不会正确计算待定交易。我们来看一个例子：

----
web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", "pending")
40
web3.eth.sendTransaction({from: web3.eth.accounts[0], to: "0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.toWei(0.01, "ether")});
web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", "pending")
41
web3.eth.sendTransaction({from: web3.eth.accounts[0], to: "0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.toWei(0.01, "ether")});
web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", "pending")
41
web3.eth.sendTransaction({from: web3.eth.accounts[0], to: "0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.toWei(0.01, "ether")});
web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", "pending")
41
----

如您所见，我们发送的第一笔交易将交易计数增加到了41，显示了待处理交易。但是，当我们快速连续发送3个交易时，getTransactionCount调用没有正确计数它们。它只计算一个，即使在mempool中有3个挂起交易。如果等待几秒钟，一旦区块被挖矿，getTransactionCount调用将返回正确的数字。但在此期间，虽然有多项交易挂起，但对我们无帮助。

当您创建构造交易的应用程序时，无法依赖getTransactionCount处理挂起的交易。只有在挂起和确认相同（所有未完成的交易都已确认）时，才能信任getTransactionCount的输出以启动您的nonce计数器。此后，请记录您的应用程序中的nonce，直到每笔交易确认。

Parity的JSON RPC接口提供了parity_nextNonce函数，该函数返回应在交易中使用的下一个nonce。parity_nextNonce函数可以正确地计算nonce，即使您连续快速构建多个交易而不确认它们。

[[parity_curl]]
Parity有一个用于访问JSON RPC接口的Web控制台，但在这里我们使用一个命令行HTTP客户端来访问它：

----
curl --data '{"method":"parity_nextNonce","params":["0x9e713963a92c02317a681b9bb3065a8249de124f"],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545

{"jsonrpc":"2.0","result":"0x32","id":1}
----

[[gaps_nonce]]
===== nonce空缺、重复nonce和确认

如果您正在以编程方式创建交易，则必须跟踪nonce，特别是如果您同时从多个独立进程执行此操作。

以太坊网络顺序处理交易。这意味着，如果您使用nonce 0传输交易，然后使用nonce 2传输交易，则第二个交易不会被确认（挖矿）。它将存储在mempool中，而以太坊网络等待丢失的nonce出现。所有节点都会假设丢失的nonce被简单地延迟，而nonce 2的交易提前接收到（失序）。

如果您随后发送缺失的nonce 1的交易，则两个交易（nonce 1和nonce 2）将被确认（挖矿）。一旦你填补了空白，网络可以确认（挖矿）它在mempool中的失序交易。

这意味着如果您按顺序创建多个交易，并且其中一个交易未被挖矿，则所有后续交易将“卡住”，等待丢失的nonce。交易可能在nonce序列中产生无意的“空缺”，可能因为它无效或燃料不足。为了交易继续，你必须用空缺的nonce发送一个有效的交易。

另一方面，如果您不小心重复了一个nonce，例如通过传输具有相同nonce的两个交易，但收件人或值不同，则其中一个将被确认，一个将被拒绝。哪一个被确认将取决于它们到达第一个接收它们的验证节点的顺序。

正如你所看到的，跟踪nonce是必要的，如果你的应用程序没有正确地管理这个过程，你会遇到问题。不幸的是，如果你试图同时做到这一点，事情会变得更加困难，我们将在下一节中看到。

[[concurrency]]
===== 并发性、交易起始和nonce

并发是计算机科学的一个复杂方面，有时候它会突然出现，特别是在像Ethereum这样的去中心/分布式实时系统中。

简单来说，并发性是指当多个独立系统同时进行计算。这些可以在相同的程序（例如线程）中，在相同的CPU（例如多处理器）上，或在不同的计算机（即分布式系统）上。按照定义，以太坊是一个允许操作（节点、客户端、DApps）并发的系统，但是强制实施一个单一状态（例如在每个被挖矿区块中只有一个公共/共享的系统状态）。

现在，假设我们有多个独立的钱包应用程序正在从同一个地址或多个地址生成交易。这种情况的一个例子是热钱包的兑换处理提款。理想情况下，您希望有多台计算机处理提款，以便它不会成为瓶颈或单点故障。然而，这很快就会变成问题，因为有多台计算机生成提款会导致一些棘手的并发问题，其中最重要的是选择nonce。多台电脑如何从同一个热钱包账户协调生成、签署和广播交易？

您可以使用一台计算机根据先到先得的原则为签署交易的计算机分配nonce。但是，这台电脑现在是单点故障。更糟糕的是，如果分配了多个nonce，而其中一个未使用（因为某计算机处理具有该nonce的交易失败），所有后续交易都会卡住。

您可以生成交易，但不要为它们签名或为其分配nonce。然后将它们排队到一个签名它们的单个节点，并记录nonce。再次，你有一个单点故障。作为您操作组成部分的nonce的签名和跟踪，可能在负载下变得拥塞，而生成未签名交易的部分并不需要实现并行化。你有并发性，但没有用在过程的有用部分。

最后，除了跟踪独立流程中的账户余额和交易确认的难度之外，这些并发问题迫使大多数实现趋向于避免并发和创建瓶颈，如用单个流程处理所有提款交易。

[[tx_gas]]
=== 交易燃料

我们在<<gas>>中详细讨论 _燃料_ 。但是，让我们介绍一些交易中gasPrice和startGas组件角色的基本知识。

gas是以太坊的燃料。燃料不是以太币 - 它是一个独立的虚拟货币，汇率参照以太币。以太坊使用燃料来控制交易可以花费的资源量，因为它将在全球数千台计算机上处理。开放式（图灵完整）计算模型需要某种形式的计量，以避免拒绝服务攻击或无意中的资源耗尽交易。

燃料与以太币分离，以保护系统免受随着以太币价值快速变化而产生的波动。

交易中的gasPrice字段允许交易创建者设置每个单位的燃料的汇率。燃料价格以wei做计量单位。例如，在我们最近为本书中的一个例子创建的交易中，我们的钱包将gasPrice设置为3 Gwei（3 Giga-wei，30 billion wei）。

受欢迎的网站ethgasstation.info提供关于以太坊主要网络的当前燃料价格和其他相关燃料指标的信息：

https://ethgasstation.info/

钱包可以调整他们发起的交易中的gasPrice，从而更快地确认（挖矿）交易。gasPrice越高，交易可能确认的速度越快。相反，较低优先级的交易可能会降低他们愿意为燃料支付的价格，导致确认速度减慢。可以设置的最低gasPrice为零，这意味着免费的交易。在大块空间需求低的时期，这些交易将被确认。

[TIP]
====
最低可接受的gasPrice为零。这意味着钱包可以产生完全免费的交易。根据能力的不同，这些可能永远不会被确认，但协议中没有任何内容禁止免费交易。您可以在以太坊区块链中找到几个此类交易成功确认的例子。
====

[[gas_price_suggestion]]
web3界面通过计算几个区块的中间价格来提供gasPrice建议：

----
truffle(mainnet)> web3.eth.getGasPrice(console.log)
truffle(mainnet)> null BigNumber { s: 1, e: 10, c: [ 10000000000 ] }
----

[[calc_gas_price]]
与燃料有关的第二个重要字段是 +startGas+。这在<<gas>>中有更详细的解释。简单来说， +startGas+定义了交易创建人愿意花费多少个单位燃料来完成交易。对于简单的支付，意味着将以太币从一个EOA转移到另一个EOA的交易，所需的燃料量固定为21,000个燃料单位。要计算需要花费多少以太币，你需要用你愿意支付的gasPrice乘以21,000：

----
truffle(mainnet)> web3.eth.getGasPrice(function(err, res) {console.log(res*21000)} )
truffle(mainnet)> 210000000000000
----

如果您的交易的目的地址是合约，则可以估计所需的燃料量，但无法准确确定。这是因为合约可以评估不同的条件，导致不同的执行路径和不同的燃料成本。这意味着合约可能只执行简单的计算或更复杂的计算，具体取决于您无法控制且无法预测的条件。为了证明这一点，让我们使用一个颇为刻意的例子：每次调用一个合约时，它会为一个计数器加一，并在第100次（仅）计算一些复杂的事情。如果你有99次合约发生了一件事情，但在100件事情上发生了完全不同的事情。您要支付的燃料数量取决于交易确认前有多少其他交易调用了该函数。也许你的估计是基于第99次交易，而在你的交易被确认之前，其他人第99次调用了合约。现在，您是第100个要调用的交易，计算工作量（和燃料成本）要高得多。

借用以太坊使用的常见类比，您可以将startGas视为汽车中的油箱（您的汽车是交易）。你认为它旅行（验证交易所需的计算）需要多少燃料，你就向邮箱中填充多少燃料。您可以在某种程度上估算金额，但您的旅程可能会有意想不到的变化，例如改道（更复杂的执行路径），这会增加燃料消耗。

然而，与燃料箱的比较有些误导。这更像是一家加油站公司的信用账户，根据您实际使用的燃料量，在旅行完成后支付。当您传输您的交易时，首先验证步骤之一是检查它源自的帐户是否有足够的以支付gasPrice * startGas费用。但是，在交易执行结束之前，金额实际上并未从您的帐户中扣除。您只收取最终交易实际消耗的燃料，但在发送交易之前，您必须有足够的余额支付您愿意支付的最高金额。

[[tx_recipient]]
=== 交易接收者

交易的接收者在to字段中指定。这包含一个20字节的以太坊地址。地址可以是EOA或合约地址。

以太坊没有进一步验证这个领域。任何20字节的值都被认为是有效的。如果20字节的值对应于没有相应私钥的地址，或没有相应的合约，则该交易仍然有效。以太坊无法知道某个地址是否从公钥正确导出（及从私钥导出）。

[WARNING]
====
以太坊不能也不会验证交易中的接收者地址。您可以发送到没有相应私钥或合约的地址，从而“销毁”以太币，使其永远不能花费。验证应该在用户界面级完成。
====

发送一个交易到一个无效的地址会_销毁_以太币，使其永远无法访问（无法花费），因为没有签名可以生成去花费它。假定地址验证发生在用户界面级别（请参见<<eip-55>>或<<icap>>）。事实上，有很多合理的理由来销毁以太币，其中包括作为游戏理论抑制支付渠道和其他智能合约作弊。

[[tx_value_data]]
=== 交易value和data

交易的主要“有效载荷”包含在两个字段中：值和数据。交易可以同时有价值和数据、只有值、只有数据、值和数据都没有。所有四种组合都是有效的。

只有值的交易是 _支付_ （译者：转账）。只有数据的交易是一个 _调用_ 。既没有价值也没有数据的交易，这可能只是浪费燃料！但它仍然有可能。

让我们尝试所有上述组合：

[[src_dest_address]]
首先，我们在钱包中设置源地址和目标地址，以使演示更易于阅读：

.设置源地址和目标地址
[source,javascript]
----
src = web3.eth.accounts[0];
dst = web3.eth.accounts[1];
----

[[tx_value_nodata]]
===== 有值（支付）但没有数据载荷的交易

[[tx_value_nodata_src]]
.有值，没有数据
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, value: web3.toWei(0.01, "ether"), data: ""});
----

我们的钱包显示确认屏幕，指示要发送的值，但没有数据负载：

[[parity_txdemo_value_nodata]]
.Parity钱包显示有值的交易，但没有数据
image::images/parity_txdemo_value_nodata.png["Parity钱包显示有值的交易，但没有数据"]

[[tx_value_data]]
===== 有值（支付）和数据载荷的交易

[[tx_value_data_src]]
.值和数据
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, value: web3.toWei(0.01, "ether"), data: "0x1234"});
----

我们的钱包显示一个确认屏幕，指示要发送的值和数据负载：

[[parity_txdemo_value_data]]
.显示有值和数据交易的parity钱包
image::images/parity_txdemo_value_data.png["显示包含值和数据的交易的Parity钱包"]

[[tx_novalue_nodata]]
===== 具有0值的交易，只有一个数据载荷

[[tx_novalue_nodata_src]]
.没有值，只有数据
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, value: 0, data: "0x1234"});
----

我们的钱包显示一个确认屏幕，显示值为0并显示数据负载：

[[parity_txdemo_novalue_data]]
.Parity钱包显示没有值的交易，只显示数据
image::images/parity_txdemo_novalue_data.png["Parity钱包显示没有值的交易，仅显示数据"]

[[tx_novalue_data]]
===== 既没有值（支付），也没有数据载荷的交易

[[tx_novalue_nodata_src]]
.没有值，没有数据
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, value: 0, data: ""}));
----

我们的钱包显示确认屏幕，显示0值并且没有数据：

[[parity_txdemo_novalue_nodata]]
.显示无值交易的平价钱包，没有数据
image::images/parity_txdemo_novalue_nodata.png["Parity钱包显示没有值也没有数据的交易"]

[[value_EOA_contracts]]
=== 将值传递给EOA和合约

当您构建包含值的以太坊交易时，它等于 _支付_ （译者：转账）。根据目的地址是否为合约，这些交易行为会有所不同。

对于EOA地址，或者更确切地说，对于未在区块链中注册为合约的任何地址，以太坊将记录状态更改，并将您发送的值添加到地址的余额中。如果地址之前没有被查看过，则会创建地址并将其余额初始化为您的付款金额。

如果目标地址（to）是合约，则EVM将执行合约并尝试调用交易的数据载荷中指定的函数（请参阅<<invocation>>）。如果您的交易中没有数据载荷，那么EVM将调用目标合约的 _fallback_ 函数，如果该函数可用，则将执行它以确定下一步该做什么。

合约可以通过在调用支付函数时立即抛出异常或由支付函数中编码的条件确定来拒绝收款。如果支付函数成功结束（没有抛出异常），则更新合约状态以反映合约的以太币余额增加。

[[data_EOA]]
=== 将数据载荷传输到EOA或合约

当您的交易包含数据载荷时，它很可能发送到合约地址。这并不意味着您无法将数据载荷发送到EOA。事实上，你可以做到这一点。但是，在这种情况下，数据载荷的解释取决于您用来访问EOA的钱包。大多数钱包忽略交易中收到的任何数据载荷到他们控制的EOA。将来，标准可能会出现，允许钱包以合约的方式解释数据载荷编码，从而允许交易调用在用户钱包内运行的函数。关键的区别在于，与合约执行不同，EOA对数据载荷的任何解释都不受以太坊共识规则的约束。

现在，假设您的交易正在将数据载荷传递到合约地址。在这种情况下，数据载荷将被EVM解释为 _函数调用_ ，调用名称指定的函数并将编码参数传递给该函数。

发送给合约的数据载荷是一个十六进制序列化的编码：

一个函数选择器::  是函数 _prototype_ 的Keccak256哈希的前4个字节。这使EVM能够明确地识别您希望调用的函数。

函数参数::  函数的参数，根据由EVM定义的各种基本类型的规则进行编码。

[[withdraw_function_src]]
我们来看一个简单的例子，来自我们的<<solidity_faucet_example>>。在Faucet.sol中，我们为提款定义了一个函数：

----
function withdraw(uint withdraw_amount) public {
----

withdraw函数的 _prototype_ 被定义为包含函数名称的字符串，随后是括号中括起来的每个参数的数据类型，并用单个逗号分隔。函数名称是withdraw，并且它只有一个参数是uint（这是uint256的别名）。所以withdraw的prototype是：

----
withdraw(uint256)
----

我们来计算这个字符串的Keccak256哈希值（我们可以使用truffle控制台或任何JavaScript web3控制台来完成此操作）：

----
web3.sha3("withdraw(uint256)");
'0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f'
----

哈希的前4个字节是0x2e1a7d4d。这是我们的“函数选择器”值，它会告诉EVM我们想调用哪个函数。

接下来，让我们计算一个值来作为参数withdraw_amount传递。我们要提现0.01以太币。我们将它编码为一个十六进制序列化的big-endian无符号256位整数，以wei计量：

----
withdraw_amount = web3.toWei(0.01, "ether");
'10000000000000000'
withdraw_amount_hex = web3.toHex(withdraw_amount);
'0x2386f26fc10000'
----

现在，我们将函数选择器添加到数量（填充为32字节）：

----
2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000
----

这是我们交易的数据载荷，调用withdraw函数并请求0.01以太币作为withdraw_amount。

[[contract_reg]]
=== 特殊交易：合约注册

有数据载荷和没有值的交易有一种特殊情况。就是 _注册_ 新合约的交易。合约注册交易被发送到一个特殊的目的地址，即零地址。简而言之，合约注册交易中的to字段包含地址0x0。该地址既不代表EOA（没有相应的私有/公共密钥对）也不代表合约。它永远不会花费以太币或初始化一个交易。它仅用作目的地，具有“注册此合约”的特殊含义。

合约注册交易不应包含以太币值，只能是包含合约编译字节码的数据载荷。此次交易的唯一效果是注册合约。

====
TODO添加示例，显示在web3控制台和etherscan中
====

尽管零地址仅用于合约注册，但它有时会收到来自各个地址的付款。对此有两种解释：无论是偶然的，导致以太的丢失，还是故意的 _以太币销毁_ （参见<<burning_ether>>)）。如果您想进行有意识的以太币销毁，您应该向网络明确您的意图，并使用专门指定的销毁地址：

[[burn_address]]
----
0x000000000000000000000000000000000000dEaD
----

[WARNING]
====
发送以太币到合约注册地址0x0或销毁地址0x0...dEaD，会让以太币变得不可花费并永远丢失。
====

[[digital_sign]]
=== 数字签名

到目前为止，我们还没有深入探讨“数字签名”的细节。在本节中，我们将探讨数字签名是如何工作的以及如何在不泄露私钥的情况下提供私钥的所有权证明。

[[ecdsa]]
==== 椭圆曲线数字签名算法（ECDSA）

以太坊使用的数字签名算法是 _椭圆曲线数字签名算法_ （简称 _ECDSA_ ）。ECDSA是用于基于椭圆曲线私钥/公钥对的数字签名的算法，如<<elliptic_curve>>中所述。

数字签名在以太坊有三个用途（请参阅下面的侧边栏）。首先，签名证明私钥的所有者，暗示着以太坊账户的所有者，已经 _授权_ 了以太币的花费或执行合约。其次，授权证明是 _不可否认的_ （non-repudiation）。第三，签名证明交易数据在交易签署后没有， _也不能被任何人修改_ 。

[[digital_signature_definition]]
.维基百科对“数字签名”的定义

****
数字签名是展示数字信息或文件真实性的数学方案。有效的数字签名使接收人有理由相信该消息是由已知的发送人（认证）创建的，发送人不能否认已发送消息（不可否认），并且消息在传输过程中未被更改（完整性） 。

_来源：https：//en.wikipedia.org/wiki/Digital_signature_
****

[[digital_sign_work]]
==== 数字签名如何工作

数字签名是由两部分组成的 _数学方案_ 。第一部分是使用消息（交易）中的私钥（签名密钥）创建签名的算法。第二部分是一个算法，允许任何人通过仅使用消息和公钥来验证签名。

[[digital_sign_create]]
===== 创建数字签名

在以太坊实施的ECDSA中，被签名的“消息”是交易，或者更确切地说，来自交易的RLP编码数据的Keccak256哈希。签名密钥是EOA的私钥。签名的结果是：

latexmath:[\(Sig = F_{sig}(F_{keccak256}(m), k)\)]

这里：

* _k_ 是签名私钥
* _m_ 是RLP编码的交易
* _F_~_keccak256_~ 是Keccak256哈希函数
* _F_~_sig_~ 是签名算法
* _Sig_ 是由此产生的签名

有关ECDSA数学的更多细节可以在<<ecdsa_math>>找到。

[[sign_function]]
函数 _F_~_sig_~ 产生一个由两个值组成的签名 +Sig+，通常称为 +R+ 和 +S+：

----
Sig = (R, S)
----

[[verify_sign]]
==== 验证签名

要验证签名，必须具有签名（R和S），序列化交易和公钥（与用于创建签名的私钥相对应）。实质上，对签名的验证意味着“只有生成此公钥的私钥的所有者才能在此交易上产生此签名。”

签名验证算法将消息（交易的散列或散列的一部分）、签名者的公钥和签名（R和S值）作为参数，如果签名对此消息和公钥有效，则返回TRUE。

[[ecdsa_math]]
==== ECDSA算法

如前所述，签名是由一个数学函数 _F_~_sig_~ 生成的，它产生一个由两个值 _R_ 和 _S_ 组成的签名。在本节中，我们更详细地研究函数 _F_~_sig_~ 。

签名算法首先生成一个 _临时_（临时）私钥/公钥对。在包括签名私钥和交易哈希的转换之后，此临时密钥对用于计算 _R_ 和 _S_ 值。

临时密钥对由两个输入值生成：

1. 一个随机数 _q_ ，用作临时私钥
2. 和椭圆曲线发生器点 _G_ 

通过 _q_ 和 _G_ ，我们生成相应的临时公钥 _Q_ (以 _Q = q*G_计算，与以太坊公钥的推导方式相同;请参阅 <<pubkey>>。数字签名的 _R_ 值就是临时公钥 _Q_ 的x坐标。

从那里算法计算签名的 _S_ 值，如：

_S_ &#8801; __q__^-1^ (__Keccak256__(__m__) + __k__ * __R__)  {nbsp} {nbsp} (_mod p_)

这里：

* _Q_ 是临时的私钥
* _R_ 是临时公钥的x坐标
* _k_ 是签名（EOA所有者）的私钥
* _m_ 是交易数据
* _p_ 是椭圆曲线的主要阶数

验证是签名生成函数的反函数，使用 _R_ ， _S_ 值和公钥生成值 _Q_ ，该值是椭圆曲线上的一个点（签名创建中使用的临时公钥）：

_Q_ &#8801; __S__^-1^ * __Keccak256__(__m__) * _G_ + __S__^-1^ * _R_ * _K_  {nbsp} {nbsp} (_mod p_)

这里：

* _R_ 和 _S_ 是签名值
* _K_ 是签名者（EOA所有者）的公钥
* _m_ 是签署的交易数据
* _G_ 是椭圆曲线发生器点
* _p_ 是椭圆曲线的主要阶数

如果所计算的点 _Q_ 的x坐标等于 _R_ ，则验证者可以断定该签名是有效的。

请注意，在验证签名时，私钥既不知道也不透露。

[TIP]
====
ECDSA必然是一门相当复杂的数学; 完整的解释超出了本书的范围。一些在线的优秀指南会逐步完成：搜索“ECDSA解释”或尝试下面这个：http://bit.ly/2r0HhGB|
====

[[tx_sign]]
==== 在实践中签署交易

为了产生有效的交易，发送人必须使用椭圆曲线数字签名算法对消息进行数字签名。当我们说“签署交易”时，我们实际上是指“签署RLP序列化交易数据的Keccak256哈希”。签名作用于交易数据的散列，而不是交易本身。

[TIP]
====
在＃2,675,000块，Ethereum实施了“Spurious Dragon”硬分叉，除其他更改外，还推出了包括交易重放保护的新签名方案。这个新的签名方案在EIP-155中指定（参见 <<eip155>>。此更改会影响签名过程的第一步，在签名之前向交易添加三个字段（v，r，s）。
====

要在以太坊签署交易，发件人必须：

1. 创建一个包含九个字段的交易数据结构：nonce，gasPrice，startGas，to，value，data，v，r，s
2. 生成交易的RLP编码的序列化消息
3. 计算此序列化消息的Keccak256散列值
4. 计算ECDSA签名，用发起EOA的私钥签名散列
5. 将ECDSA签名的计算出的r和s值插入交易中

[[raw_tx]]
==== 原始交易创建和签署

我们使用ethereumjs-tx库创建一个原始交易并签名。此示例的源代码位于GitHub存储库中的raw_tx_demo.js中：

[[raw_tx_demo_source]]
.raw_tx_demo.js：在JavaScript中创建和签署原始交易
----
include::code/web3js/raw_tx/raw_tx_demo.js[]
----

在此处下载：https://github.com/ethereumbook/ethereumbook/blob/develop/code/web3js/raw_tx/raw_tx_demo.js

[[raw_tx_demo_run]]
运行示例代码：
----
$ node raw_tx_demo.js
RLP-Encoded Tx: 0xe6808609184e72a0008303000094b0920c523d582040f2bcb1bd7fb1c7c1ecebdb348080
Tx Hash: 0xaa7f03f9f4e52fcf69f836a6d2bbc7706580adce0a068ff6525ba337218e6992
Signed Raw Transaction: 0xf866808609184e72a0008303000094b0920c523d582040f2bcb1bd7fb1c7c1ecebdb3480801ca0ae236e42bd8de1be3e62fea2fafac7ec6a0ac3d699c6156ac4f28356a4c034fda0422e3e6466347ef6e9796df8a3b6b05bed913476dc84bbfca90043e3f65d5224
----

[[raw_tx_eip155]]
==== 使用EIP-155创建原始交易

EIP-155“简单重播攻击保护”标准规定了重放攻击保护的交易编码，它在签名之前包含交易数据内的 _链标识符_ 。这确保了为一个区块链（例如以太坊主网络）创建的交易在另一个区块链（例如Ethereum Classic或Ropsten测试网络）上无效。因此，在一个网络上广播的交易不能在另一个网络上 _重播_ ，因此此标准命名为“重放攻击保护”。

EIP-155向交易数据结构中添加了三个字段v，r和s。r和s字段初始化为零。这三个字段在 _编码和散列之前_ 被添加到交易数据中。因此，三个附加字段会更改交易的散列，稍后散列会被签名。通过在被签名的数据中包含链标识符，交易签名可以防止任何更改，因为如果链标识符被修改，签名将失效。因此，EIP-155使得交易不可能在另一个链上重播，因为签名的有效性取决于链标识符。

[[sign_prefix_table]]
v签名前缀字段被初始化为链标识符，其值为：

|======
| Chain | Chain ID |
| Ethereum main net | 1 |
| Morden (obsolete), Expanse | 2 |
| Ropsten | 3 |
| Rinkeby | 4 |
| Rootstock main net | 30 |
| Rootstock test net | 31 |
| Kovan | 42 |
| Ethereum Classic main net | 61 |
| Ethereum Classic test net | 62 |
| Geth private testnets | 1337 |
|======

由此产生的交易结构是RLP编码、散列和签名。对签名算法稍作修改，以便对v前缀中的chainID进行编码。

有关更多详细信息，请参阅EIP-155规范：https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md

[[sign_prefix]]
=== 签名前缀值（v）和公钥恢复

如<<tx_struct>>中所述，交易消息不包含任何“from”字段。这是因为发起者的公钥可以直接从ECDSA签名中计算出来。一旦你有公钥，你可以很容易地计算出地址。恢复签名者公钥的过程称为 _公钥恢复_ 。

给定在<<ecdsa_math>>中计算的值r和s，我们可以计算两个可能的公钥。

首先，根据签名中的x坐标r值计算两个椭圆曲线点R和R '。有两点，因为椭圆曲线在x轴上是对称的，所以对于任何值x，都有两个可能的值适合x轴两侧的曲线。

从r，我们也计算r -1，这是R的乘法逆。

最后我们计算z，它是消息散列的n-lowest比特位，其中n是椭圆曲线的阶数。

然后两个可能的公钥是：

K~1~ = r^-1^ (sR - zG)

和

K~2~ = r^-1^ (sR^'^ - zG)

这里：

* K~1~ 和 K~2~是签名者公钥的两种可能性
* r^-1^是签名r值的乘法逆
* s是签名的值
* R和R^'^是短暂公钥 _Q_ 的两种可能性
* z是消息散列的n-lowest位
* G是椭圆曲线发生器点

为了提高效率，交易签名包含一个前缀值v，它告诉我们两个可能的R值中哪一个是临时公钥。如果v是偶数，那么R是正确的值。如果v是奇数，那么R '。这样，我们只需要计算R的一个值，而只需计算一个值。

[[offline_sign]]
=== 分离签名和传输（离线签名）

一旦交易被签署，它就可以传送到以太坊网络。创建、签署和广播交易的三个步骤通常发生在单个函数中，例如使用web3.eth.sendTransaction。但是，正如我们在<<raw_tx>>看到的，您可以通过两个单独的步骤创建和签署交易。一旦您有了一个签署的交易，您就可以使用web3.eth.sendSignedTransaction来传输它，该函数采用一个十六进制编码并签名的交易消息，并在以太坊网络上传输。

你为什么要分开交易的签署和传输？最常见的原因是安全性：签名交易的计算机必须解锁装载在内存中的私钥。传输的计算机必须连接到互联网并运行以太坊客户端。如果这两个功能都在一台计算机上，那么您的在线系统上有私钥，这非常危险。分离签名和传输功能称为 _离线签名_ ，是一种常见的安全措施。

根据您需要的安全级别，您的“离线签名”计算机可以与在线计算机有不同程度的分离，从隔离的防火墙子网（在线但隔离）到完全脱机的系统（称为*air-gapped*系统） 。在air-gapped系统中根本没有网络连接 - 计算机与在线环境隔开“空气”间隙。使用数据存储介质或（更好）网络摄像头和QR码将交易记录到带有空隙的计算机上，以签署交易。当然，这意味着您必须手动传输您想要签名的每个交易，而这不会扩展。

尽管没有多少环境可以利用完全气隙系统，但即使是小程度的隔离也具有显着的安全优势。例如，带防火墙的隔离子网只允许通过消息队列协议，可以提供大大降低的攻击面，并且比在线系统上签名的安全性高得多。许多公司使用诸如ZeroMQ（0MQ）的协议，因为它为签名计算机提供了减少的攻击面。有了这样的设置，交易就被序列化并排队等待签名。排队协议以类似于TCP套接字的方式将序列化的消息发送到签名计算机。签名计算机从队列中读取序列化的交易（仔细地），使用适当的密钥应用签名，并将它们放置在传出队列中。

[[tx_propagation]]
=== 交易传播

以太坊网络使用“flood”路由协议。每个以太坊客户端，充当 _对等网络（P2P）_ 的一个 _节点_ ，其（理想地）形成 _网状_ 网络。没有网络节点是“特殊的”，它们都作为平等的对等体。我们将使用术语“节点”来指代连接并参与P2P网络的以太坊客户端。

交易传播开始于创建以太坊节点（或从离线接收）签署的交易。交易被验证，然后传输到 _直接_ 连接到始发节点的所有其他以太坊节点。平均而言，每个以太坊节点保持与至少13个称为 _邻居_ 的其他节点的连接。每个邻居节点在收到交易后立即验证交易。如果他们同意这是有效的，他们会保存一份副本并将其传播给所有的邻居（除了来源邻居）。结果，交易从源节点向外涟漪 _泛滥_ ，直到网络中的所有节点都拥有该交易的副本。

几秒钟内，以太坊交易就会传播到全球所有以太坊节点。从每个节点的角度来看，不可能辨别交易的起源。发送给我们节点的邻居可能是交易的发起者，或者可能从其邻居那里收到它。为了能够跟踪交易的起源或干扰传播，攻击者必须控制所有节点的相当大的百分比。这是P2P网络安全和隐私设计的一部分，尤其适用于区块链。

[[chain_record]]
=== 在链中记录

尽管以太坊中的所有节点都是同等的对等节点，但其中一些节点由 _矿工_ 负责运营，并向 _矿场_ 提供交易和区块，这些 _矿场_ 是具有高性能图形处理单元（GPU）的计算机。挖矿计算机将交易添加到候选区块，并试图找到使得候选区块有效的 _工作量证明_ 。我们将在<<consensus>>中更详细地讨论这一点。

不再提及太多细节，有效的交易最终将被包含在一个交易区块中，并因此记录在以太坊区块链中。一旦挖矿成区块，交易还通过修改账户余额（在简单付款的情况下）或通过调用改变其内部状态的合约来修改以太坊singleton的状态。这些更改将以交易 _收据_ 的形式与交易一起记录，交易 _收据_ 也可能包含 _事件_ 。我们将在<<evm>>更详细地体会所有这些

我们的交易已经完成了从创建到签署EOA、传播以及最终挖矿的旅程。它改变了singleton的状态，并在区块链上留下了不可磨灭的印记。

=== 多重签名（multisig）交易

如果您熟悉比特币的脚本功能，那么您就知道有可能创建一个比特币多签名账户，该账户只能在多方签署交易时花费资金（例如，2个签名中的2个或3个签名）。以太坊的价值交易没有多重签名的规定，尽管可以部署任意条件的任意合约来处理以太币和代币的转让。

为了在多重签名情况下保护你的以太币，将它们转移到多签名合约中。无论何时您想将资金转入其他账户，所有需要的用户都需要使用常规钱包软件将交易发送至合约，从而有效授权合约执行最终交易。

这些合约也可以设计为在执行本地代码或触发其他合约之前需要多个签名。该方案的安全性最终由多重合约代码确定。

讨论和Grid +参考实现：+
https://blog.gridplus.io/toward-an-ethereum-multisig-standard-c566c7b7a3f6
